很多同学都不清楚PID是个什么东西，因为很多不是自动化的学生。他们开口就要资料，要程序。
这是明显的学习方法不对，起码，首先，你要理解PID是个什么东西。
本文以通俗的理解，以小车纵向控制举例说明PID的一些理解。
首先，为什么要做PID？
由于外界原因，小车的实际速度有时不稳定，这是其一，
要让小车以最快的时间达达到既定的目标速度，这是其二。
速度控制系统是闭环，才能满足整个系统的稳定要求，必竟速度是系统参数之一，这是其三.
    小车调速肯定不是线性的，外界因素那么多，没人能证明是线性的。如果是线性的，直接用P就可以了。
比如在PWM=60%时，速度是2M/S，那么你要它3M/S，就把PWM提高到90%。因为90/60=3/2，这样一来太完美了。
完美是不可能的。
    那么不是线性的，要怎么怎么控制PWM使速度达到即定的速度呢？即要快，又要准，又要狠。（即快准狠
）系统这个速度的调整过程就必须通过某个算法调整，一般PID就是这个所用的算法。
    可能你会想到，如果通过编码器测得现在的速度是2.0m/s,要达到2.3m/s的速度，那么我把pwm增大一点不
就行了吗？是的，增大pwm多少呢？必须要通过算法，因为PWM和速度是个什么关系，对于整个系统来说，谁也
不知道。要一点一点的试，加个1%,不够，再加1%还是不够，那么第三次你还会加1%吗？很有可能就加2%了。
通过PID三个参数得到一个表达式：△PWM=a *△V1+b *△V2+c *△V3,a b c是通过PID的那个长长的公式展开
，然后约简后的数字，△V1 ，△V2 ，△V3 此前第一次调整后的速度差 ,第二次调整后的速度差,第三次。。
。。。一句话，PID要使当前速度达到目标速度最快，需要建立如何调整pwm和速度之间的关系。

输入输出是什么：
输入就是前次速度，前前次速度，前前前次速度。
输出就是你的PWM应该增加或减小多少。












为了避免教科书公式化的说明，本文用口语化和通俗的语言描述。虽然不一定恰当，但意思差不多，就是那个事。如果要彻头彻尾地弄PID，建议多调试，写几个仿真程序。

PID一般有两种：位置式PID和增量式PID。在小车里一般用增量式，为什么呢？位置式PID的输出与过去的所有状态有关，计算时要对e（每一次的控制误差）进行累加，这个计算量非常大，而明没有必要。而且小车的PID控制器的输出并不是绝对数值，而是一个△，代表增多少，减多少。换句话说，通过增量PID算法，每次输出是PWM要增加多少或者减小多少，而不是PWM的实际值。
下面均以增量式PID说明。
  这里再说一下P、I、D三个参数的作用。P=Proportion，比例的意思，I是Integral，积分，D是Differential微分。
打个比方，如果现在的输出是1，目标输出是100，那么P的作用是以最快的速度达到100，把P理解为一个系数即可；而I呢？大家学过高数的，0的积分才能是一个常数，I就是使误差为0而起调和作用；D呢？大家都知道微分是求导数，导数代表切线是吧，切线的方向就是最快到至高点的方向。这样理解，最快获得最优解，那么微分就是加快调节过程的作用了。
公式本来需要推导的，我就不来这一套了。直接贴出来：
看看最后的结果： 
△Uk=A*e(k)+B*e(k-1)+C*e(k-2)
这里KP是P的值，TD是D的值，1/Ti是I的值，都是常数，哦，还有一个T，T是采样周期，也是已知。而A
B
C是由P I D换算来的，按这个公式，就可以简化计算量了，因为 P I D 是常数，那么A B C可以用一个宏表示。这样看来，只需要求e(k) e(k-1) e(k-2)就可以知道△Uk的值了，按照△Uk来调节PWM的大小就OK了。PID三个参数的确定有很多方法，不在本文讨论范围内。采样周期也是有据可依的，不能太大，也不能太小










PID实际编程的过程的，要注意的东西还是有几点的。PID这东西可以做得很深。
1 PID的诊定。凑试法，临界比例法，经验法。
2 T的确定，采样周期应远小于过程的扰动信号的周期，在小车程序中一般是ms级别。
3 目标速度何时赋值问题，如何更新新的目标速度?这个问题一般的人都乎略了。目标速度肯定不是个恒定的，那么何时改变目标速度呢？
4 改变了目标速度，那么e(k) e(k-1) e(k-2)怎么改变呢？是赋0还是要怎么变？
5 是不是PID要一直开着？
6 error为多少时就可以当速度已达到目标？
7 PID的优先级怎么处理，如果和图像采集有冲突怎么办？
8 PID的输入是速度，输出是PWM，按理说PWM产生速度，但二者不是同一个东西，有没有问题？
9 PID计算如何优化其速度？指针，汇编，移位？都可以试！
//*****************************************************
//定义PID结构体
//*****************************************************
typedef struct PID
{
    int SetPoint; //设定目标 Desired Value
    double Proportion; //比例常数 Proportional Const
    double Integral; //积分常数 Integral Const
    double Derivative; //微分常数 Derivative Const
    int LastError; //Error[-1]
    int PrevError; //Error[-2]
} PID;
//*****************************************************
//定义相关宏
//*****************************************************
#define P_DATA 100
#define I_DATA
0.6
#define D_DATA
1
#define HAVE_NEW_VELOCITY 0X01
//*****************************************************
//声明PID实体
//*****************************************************
static PID sPID;
static PID *sptr = &sPID;
//*****************************************************
//PID参数初始化
//*****************************************************
void IncPIDInit(void)
{
sptr->LastError = 0; //Error[-1]
sptr->PrevError = 0; //Error[-2]
sptr->Proportion = P_DATA; //比例常数 Proportional Const
sptr->Integral = I_DATA; //积分常数Integral Const
sptr->Derivative = D_DATA; //微分常数 Derivative Const
sptr->SetPoint =100; 
目标是100
}
//*****************************************************
//增量式PID控制设计
//*****************************************************
int IncPIDCalc(int NextPoint)
{
   int iError, iIncpid; //当前误差
   iError = sptr->SetPoint - NextPoint; //增量计算
   iIncpid = sptr->Proportion * iError //E[k]项
             - sptr->Integral * sptr->LastError //E[k－1]项
             + sptr->Derivative * sptr->PrevError; //E[k－2]项
    sptr->PrevError = sptr->LastError; 
//存储误差，用于下次计算
    sptr->LastError = iError;
    return(iIncpid);
//返回增量值
}
Int g_CurrentVelocity;
Int g_Flag;
void main(void)
{


DisableInterrupt
InitMCu();

IncPIDInit();
g_CurrentVelocity=0;
//全局变量也初始化
g_Flag=0;
//全局变量也初始化
EnableInterrupt;



While(1)
{

if (g_Flag& HAVE_NEW_VELOCITY)

{

PWMOUT+= IncPIDCalc(CurrentVelocity);

g_Flag&=~ HAVE_NEW_VELOCITY;
}
}
}
//****************************************
//采样周期T
//****************************************
Interrrupt TIME void
{

CurrentVelocity =GetCurrentVelocity;

g_Flag|= HAVE_NEW_VELOCITY;
}





有一种控制算法比PID调节规律更有效、更方便的了。现在一些时髦点的调节器基本源自PID。甚至可以这样说：PID调节器是其它控制调节算法的妈。 
为什么PID应用如此广泛、又长久不衰？ 

因为PID解决了自动控制理论所要解决的最基本问题，既系统的稳定性、快速性和准确性。调节PID的参数，可实现在系统稳定的前提下，兼顾系统的带载能力和抗扰能力，同时，在PID调节器中引入积分项，系统增加了一个零积点，使之成为一阶或一阶以上的系统，这样系统阶跃响应的稳态误差就为零。 
由于自动控制系统被控对象的千差万别，PID的参数也必须随之变化，以满足系统的性能要求。这就给使用者带来相当的麻烦，特别是对初学者。下面简单介绍一下调试PID参数的一般步骤： 
1．负反馈 
自动控制理论也被称为负反馈控制理论。首先检查系统接线，确定系统的反馈为负反馈。例如电机调速系统，输入信号为正，要求电机正转时，反馈信号也为正（PID算法时，误差=输入-反馈），同时电机转速越高，反馈信号越大。其余系统同此方法。 
2．PID调试一般原则 
a.在输出不振荡时，增大比例增益P。 
b.在输出不振荡时，减小积分时间常数Ti。 
c.在输出不振荡时，增大微分时间常数Td。 
3．一般步骤 
a.确定比例增益P 
确定比例增益P 时，首先去掉PID的积分项和微分项，一般是令Ti=0、Td=0（具体见PID的参数设定说明），使PID为纯比例调节。输入设定为系统允许的最大值的60%~70%，由0逐渐加大比例增益P，直至系统出现振荡；再反过来，从此时的比例增益P逐渐减小，直至系统振荡消失，记录此时的比例增益P，设定PID的比例增益P为当前值的60%~70%。比例增益P调试完成。 
b.确定积分时间常数Ti 
比例增益P确定后，设定一个较大的积分时间常数Ti的初值，然后逐渐减小Ti，直至系统出现振荡，之后在反过来，逐渐加大Ti，直至系统振荡消失。记录此时的Ti，设定PID的积分时间常数Ti为当前值的150%~180%。积分时间常数Ti调试完成。 
c.确定积分时间常数Td 
积分时间常数Td一般不用设定，为0即可。若要设定，与确定 P和Ti的方法相同，取不振荡时的30%。 
d.系统空载、带载联调，再对PID参数进行微调，直至满足要求